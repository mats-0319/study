# tree

> 本节的树节点包含key、value数据，一棵树中不应存在key相同的节点，当试图插入一个key已存在的节点时，仅更新对应节点的value

## 二叉搜索树(binary search tree)

一般来说，BST更适用于查询场景，插入和删除场景与堆结构更匹配

约定：如果一个BST全部叶子节点的高度差不大于1，我们说这个BST是**高度平衡**的，简称**平衡**的

向BST插入数据，可能破坏BST的平衡结构，极端情况下，BST将变成单链表、查询效率将退化为`O(n)`，所以对BST进行插入或删除操作时，应额外维护其平衡结构

最早被发明的平衡二叉搜索树为AVL树

## AVL树(Adelson-Velsky and Landis Tree)

AVL树是自平衡的二叉搜索树，AVL树通过左旋、右旋操作平衡树的高度

右旋：（左旋是右旋的镜像）

1. 根节点的左子节点成为新的根节点
2. 若新根节点存在右子节点，则将其重新挂载成原根节点的左子节点
3. 原根节点成为新根节点的右子节点

平衡规则：

约定：

1. h：节点高度，空节点高度为`-1`（方便计算），非空节点高度为**其左右子节点高度较大者+1**
2. b：平衡因子(balance factor)，仅定义于非空节点，计算规则为**节点的左子节点高度-节点的右子节点高度**

当**平衡因子的绝对值大于1**时，开始平衡：（以下使用**根节点(root node，简称n)**表示**最先触发平衡行为的节点**）

1. LL型：因为在根节点左子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) > 0`
    2. 将根节点右旋一次即可恢复平衡结构
2. LR型：因为在根节点左子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) < 0`
    2. 将根节点的左子节点左旋一次，再将根节点右旋一次即可恢复平衡结构
3. RR型：因为在根节点右子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) < -1`且`b(n.r) < 0`
    2. 将根节点左旋一次即可恢复平衡结构
4. RL型：因为在根节点右子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) < -1`且`b(n.r) > 0`
    2. 将根节点的右子节点右旋一次，再将根节点左旋一次即可恢复平衡结构

其中，LL型与RR型互为镜像结构、LR型与RL型互为镜像结构

理解：

1. 触发平衡行为时，为什么只有上述四种情况？  
   说明：以下描述不考虑二叉树**镜像**情况，即对于RR情况的讨论，包含在LL情况中  
   在L*型不平衡情况中，我们通过右旋恢复平衡结构，此时，对于根节点的左子节点：其左子树高度不变，右子树高度+1  
   这可能导致根节点的左子节点的平衡结构被破坏  
   所以我们在右旋之前，首先保证根节点的左子节点，也就是新的根节点的平衡  
   至于实现方式，则是在新的根节点平衡因子为负时（右子树比左子树高），将其左旋一次
2. 删除树中间的一个节点，如何维护呢？  
   一种办法是可以直接选择其右子树的最左节点，将其挪到删除节点的位置，然后平衡删除节点右子树  
   而我采用的办法是不断选择高度较高的子树，将其值向上复制，直到叶子节点，直接删除它  
   两种办法主要区别在于真实删除哪个节点，方法二可能会在平衡上少做一些功夫

## 红黑树(red-black tree)(draft)

红黑树是一种自平衡二叉查找树，具有以下性质：

1. 每个节点都有且只有一个颜色：红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色
    1. 红黑树的叶子节点，是在传统意义上的叶子节点再向下抽象一层。这一句话对于理解概念没啥用处，只是为了实现方便(?)
    2. 本文档不采用该针对红黑树的**叶子节点**定义，当文档中提到**叶子节点**时，仍表示没有子节点的节点
4. 每个红色节点的子节点是黑色
    1. 即不能出现相连的红色节点
5. 任选一个节点作为根节点，根节点到它的每个叶子节点的路径都包含相同数量的黑色节点
    1. 将红黑树的这种平衡称作**黑色完美平衡**

说明：红黑树不同于AVL树，它的左右子树高度可能相差很大，例如左子树黑-红相间，而右子树全黑。理论存在，实际不知道

红黑树通过左旋、右旋和变色实现平衡，其中左旋、右旋操作与AVL树一致

约定：针对插入操作，局部范围内，将准备插入的节点称为**新节点**，新节点的父节点称为**父节点**，父节点的父节点称为**根节点**

红黑树的插入操作：`insert(key, value)`

1. 空树：生成新的节点作为根节点，颜色设置为黑色
2. 目标key已存在：更新对应节点的value
3. 父节点为黑色：生成新的节点作为子节点，颜色设置为红色
4. 父节点为红色：
    1. 根节点只有一个子节点（即，此时的二叉树退化为链表）：（R*型不平衡情况请自行镜像）
        1. LL型：根节点右旋；新的根节点设置为黑色，其子节点均设置为红色
        2. LR型：父节点左旋，根节点右旋；新的根节点设置为黑色，其子节点均设置为红色
    2. 根节点包含全部两个子节点：将父节点及其兄弟节点设置为黑色，将根节点设置为红色
        1. 若局部的根节点不是整棵树的根节点（即根节点还有父节点），且根节点的父节点是红色，则继续向上设置颜色
        2. 若递归到了整棵树的根节点，记得不要将其设置为红色

红黑树的插入操作存在自底向上的遍历，所以在实现上，每个节点应持有指向其父节点的指针

红黑树的删除操作：`delete(key)`

说明：  
如果要删除的节点是一个红色的叶子节点，那么可以直接删除它，不需要任何额外操作  
参考AVL树我的删除策略，一个有趣的思路是：将删除节点作为根节点，若根节点有红色的叶子节点，则沿着这条路线更新节点的值，然后删除这个红色叶子节点  
这样一来，除非删除节点的所有叶子节点都是黑色，否则事情会简单许多，先学完黑色怎么删吧

删除黑色节点；  
删除黑色节点必然破坏红黑树的**黑色完美平衡**性质，应该如何补救呢？

## B树(B-tree)(draft)

B树是一种自平衡的树，可以在对数时间内完成查找、顺序访问、插入以及删除操作

概括来说，B树是多叉查找树，与自平衡二叉查找树相比，B树适用于读写相对大的数据块的存储系统——例如磁盘，  
可以通过减少定位记录时所经历的中间过程，加快存取速度；常用于实现数据库与文件系统
