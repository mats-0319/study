# tree

> 本节的树节点包含key、value数据，一棵树中不应存在key相同的节点，当试图插入一个key已存在的节点时，仅更新对应节点的value

## 二叉搜索树(binary search tree)

一般来说，BST更适用于查询场景，插入和删除场景与堆结构更匹配

约定：如果一个BST全部叶子节点的高度差不大于1，我们说这个BST是**高度平衡**的，简称**平衡**的

向BST插入数据，可能破坏BST的平衡结构，极端情况下，BST将变成单链表、查询效率将退化为`O(n)`，所以对BST进行插入或删除操作时，应额外维护其平衡结构

最早被发明的平衡二叉搜索树为AVL树

## AVL树(Adelson-Velsky and Landis Tree)

AVL树是自平衡的二叉搜索树，AVL树通过左旋、右旋操作平衡树的高度

右旋：（左旋是右旋的镜像）

1. 根节点的左子节点成为新的根节点
2. 若新根节点存在右子节点，则将其重新挂载成原根节点的左子节点
3. 原根节点成为新根节点的右子节点

平衡规则：

约定：

1. h：节点高度，空节点高度为`-1`（方便计算），非空节点高度为**其左右子节点高度较大者+1**
2. b：平衡因子(balance factor)，仅定义于非空节点，计算规则为**节点的左子节点高度-节点的右子节点高度**

当**平衡因子的绝对值大于1**时，开始平衡：（以下使用**根节点(root node，简称n)**表示**最先触发平衡行为的节点**）

1. LL型：因为在根节点左子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) > 0`
    2. 将根节点右旋一次即可恢复平衡结构
2. LR型：因为在根节点左子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) < 0`
    2. 将根节点的左子节点左旋一次，再将根节点右旋一次即可恢复平衡结构
3. RR型：因为在根节点右子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) < -1`且`b(n.r) < 0`
    2. 将根节点左旋一次即可恢复平衡结构
4. RL型：因为在根节点右子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) < -1`且`b(n.r) > 0`
    2. 将根节点的右子节点右旋一次，再将根节点左旋一次即可恢复平衡结构

其中，LL型与RR型互为镜像结构、LR型与RL型互为镜像结构

理解：

1. 触发平衡行为时，为什么只有上述四种情况呢？  
   说明：以下描述不考虑二叉树**镜像**情况，即对于RR情况的讨论，包含在LL情况中  
   在L*型不平衡情况中，我们通过右旋恢复平衡结构，而右旋，对于根节点的左子节点：其左子树高度不变，右子树高度+1  
   这可能导致根节点的左子节点的平衡结构被破坏  
   所以我们在右旋之前，首先保证根节点的左子节点，也就是新的根节点在右旋之后还是平衡的  
   至于实现方式，则是在新的根节点平衡因子为负时（右子树比左子树高），将其左旋一次
2. 删除树中间的一个节点，如何维护呢？  
   一种办法是可以直接选择其右子树的最左节点，将其挪到删除节点的位置  
   而我采用的办法是不断选择高度较高的子树，将其值向上复制，直到叶子节点，直接删除它  
   两种办法主要区别在于真实删除哪个节点，方法二可能会在平衡上少做一些功夫

## 红黑树(red-black tree)(draft)

红黑树是一种自平衡二叉查找树，具有以下性质：

1. 每个节点都有且只有一个颜色：红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色
    1. 红黑树的叶子节点，是在传统意义上的叶子节点再向下抽象一层。这一句话对于理解概念没啥用处，只是为了实现方便(?)
    2. 本文档不采用该针对红黑树的**叶子节点**定义，以下提到**叶子节点**时，默认表示没有子节点的节点
4. 不能出现两个相连的红色节点
5. 任选一个节点作为根节点，根节点到它的每个叶子节点的路径上，都包含相同数量的黑色节点
    1. 推论：不存在一个节点，它只有一个黑色的子节点，而另一个子节点为空的情况

说明：红黑树不同于AVL树，它的左右子树高度可能相差很大，例如左子树黑-红相间，而右子树全黑。理论存在，实际不知道

红黑树通过左旋、右旋和变色实现平衡，其中左旋、右旋操作与AVL树一致

约定：针对插入操作，局部范围内，将准备插入的节点称为**新节点(n)**，新节点的父节点称为**父节点(p)**，父节点的父节点称为**根节点(r)**

红黑树的插入操作：`insert(key, value)`

1. 空树：生成新的节点作为根节点，颜色设置为黑色
2. 目标key已存在：更新对应节点的value
3. 父节点为黑色：生成新的节点作为子节点，颜色设置为红色
4. 父节点为红色：（插入新节点，参考上一步）
    1. 为什么父节点是叶子节点：新的节点要挂载到父节点上，所以父节点原本最多只有一个子节点；  
       又因为父节点为红色，如果有子节点，只能是黑色；而黑色的子节点又会改变性质5的值  
       结论：父节点是叶子节点  
       推论：父节点可以没有兄弟节点，如果有，一定是红色
    2. 父节点没有兄弟节点（即，此时的二叉树退化为链表）：（参考AVL树的旋转描述，R*型不平衡情况请自行镜像）
        1. LL型：根节点右旋；新的根节点设置为黑色，原根节点设置为红色
        2. LR型：父节点左旋，变成LL型，余下步骤按照LL型处理
        3. 平衡之后的根节点是黑色，其性质5的值没有变化（都是1），所以不需要额外平衡
    3. 父节点有兄弟节点：
       1. 将父节点及其兄弟节点设置为黑色，将根节点(r)设置为红色
       2. 若根节点(r)不存在父节点（即局部根节点即是整棵树的根节点），则将根节点设置为黑色（性质2）
       3. 若根节点存在父节点，且其父节点为黑色：不做任何操作
       4. 若根节点存在父节点，且其父节点为红色：将根节点(r)定义为新的待插入节点(n)，并基于此重新定义p、r
           1. 说明：因为p是红色的，所以它必然有父节点，即r必然存在
           2. p的另一个子节点（另一个子节点：相对于n）为黑色：将r设置为红色、p设置为黑色，向另一个子节点的方向旋转r
           3. p的另一个子节点为红色：设置p为红色、其两个子节点均为黑色，一直向上，直到**p是根节点**或**r为黑色**或**4.3.4.2.情景**

红黑树的插入操作存在自底向上的访问，所以在实现上，每个节点应持有指向其父节点的指针

红黑树的删除操作：`delete(key)`

- 只要删除节点往下，有一个红色节点

1. 找一个最深的红色节点，递归提升删除节点到红色节点这一段，将红色节点设置为黑色
2. 从红色节点开始向下递归，提升当前节点的一个子节点，如果存在另一个子节点，则设置其为红色，直到叶子节点；删除叶子节点
    1. 因为选择的红色节点已经是最深的了，不存在子节点还有红色的情况，所以在提升值的过程中，可以不考虑颜色

因为最终结果是删除了一个红色节点，不影响红黑树性质5，不需要额外的平衡操作

- 如果删除节点往下，全是黑色节点

1. 将删除节点左子节点提升上来，右子节点直接设置为红色
2. 从删除节点向下遍历提升节点，提升左子节点，将右子节点设置为红色，直到提升节点为叶子节点；删除提升节点
3. 从删除节点向上遍历，将父节点的另一个子节点设置为红色，直到根节点或父节点的另一个子节点已经是红色
    1. 如果父节点(p)的另一个子节点已经是红色，则将根节点(r)向黑色节点方向旋转，然后将新的根节点（原红色节点）设置为黑色，  
       如果新的根节点的一颗子树，在旋转过程中发生了重新挂载（即挂载到原根节点上），则将挂载树的根节点设置为红色

不同于删除红色节点，本节将删除一个黑色节点，导致删除节点到它每一个叶子节点路径上的黑色节点数量-1，所以需要向上平衡

## B树(B-tree)(draft)

B树是一种自平衡的树，可以在对数时间内完成查找、顺序访问、插入以及删除操作

概括来说，B树是多叉查找树，与自平衡二叉查找树相比，B树适用于读写相对大的数据块的存储系统——例如磁盘，  
可以通过减少定位记录时所经历的中间过程，加快存取速度；常用于实现数据库与文件系统
