# tree

> 本节的树节点包含key、value数据，一棵树中不应存在key相同的节点，当试图插入一个key已存在的节点时，仅更新对应节点的value

## 二叉搜索树(binary search tree)

一般来说，BST更适用于查询场景，插入和删除场景与堆结构更匹配

约定：如果一个BST全部叶子节点的高度差不大于1，我们说这个BST是**高度平衡**的，简称**平衡**的

向BST插入数据，可能破坏BST的平衡结构，极端情况下，BST将变成单链表、查询效率将退化为`O(n)`，所以对BST进行插入或删除操作时，应额外维护其平衡结构

最早被发明的平衡二叉搜索树为AVL树

## AVL树(Adelson-Velsky and Landis Tree)

AVL树是自平衡的二叉搜索树，AVL树通过左旋、右旋操作平衡树的高度

右旋：（左旋是右旋的镜像）

1. 根节点的左子节点成为新的根节点
2. 若新根节点存在右子节点，则将其重新挂载成原根节点的左子节点
3. 原根节点成为新根节点的右子节点

约定：

1. h：节点高度，空节点高度为`-1`（方便计算），非空节点高度为**其左右子节点高度较大者+1**
2. b：平衡因子(balance factor)，仅定义于非空节点，计算规则为**节点的左子节点高度-节点的右子节点高度**
3. 根节点(n)：最先触发平衡的节点；其子节点使用`n.l/n.r`表示

当**平衡因子的绝对值大于1**时，开始平衡

1. LL型：因为在根节点左子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) > 0`
    2. 右旋n
2. LR型：因为在根节点左子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) < 0`
    2. 左旋n.l，右旋n
    3. 理解：左旋n.l后，同LL型
3. RR型：`b(n) < -1`且`b(n.r) < 0`，是LL型的镜像结构
4. RL型：`b(n) < -1`且`b(n.r) > 0`，是LR型的镜像结构

理解：

1. 触发平衡行为时，为什么只有上述四种情况呢？  
   说明：以下描述不考虑二叉树**镜像**情况，即对于RR情况的讨论，包含在LL情况中  
   在L*型不平衡情况中，我们通过右旋恢复平衡结构，而右旋，对于根节点的左子节点：其左子树高度不变，右子树高度+1  
   这可能导致根节点的左子节点的平衡结构被破坏  
   所以我们在右旋之前，首先保证根节点的左子节点，也就是新的根节点在右旋之后还是平衡的  
   至于实现方式，则是在新的根节点平衡因子为负时（右子树比左子树高），将其左旋一次
2. 为什么选择现在的这种删除节点的方法呢？  
   先简单介绍一下现在的删除方式：
    1. 使用删除节点高度较高子树的根节点（以下简称高节点）的值覆盖当前节点的值，将高节点定义为删除节点
    2. 重复上一步，直到删除节点是叶子节点
    3. 删除叶子节点

   这样做可以统一处理全部情景，对比我想到的另一种方法，根据删除节点在树中的位置：
    1. 删除节点是叶子节点：直接删除
    2. 删除节点只有一个子节点：删除**删除节点**，连接删除节点的父节点与子节点
    3. 删除节点有两个子节点：选择删除节点的右子树的最左节点（比删除节点大的最小节点，以下简称替代节点），使用替代节点的值覆盖删除节点，删除替代节点
        1. 删除替代节点的步骤，参考前两步，此处只能保证删除节点不存在左子节点，即，若删除节点存在右子节点，还需要执行上一步

   从删除步骤来看，统一处理更简单；当然了，不管怎么删除，最后都要维护一遍整个树的平衡
3. 为什么我没有为AVL树节点保存其父节点的指针？  
   从代码中可以看到，对AVL树节点的操作，大多用到了父节点，那么AVL树节点是否应持有其父节点的指针呢？否  
   首先，想要父节点，在编程上存在简单的解决方案：多维护一个父节点指针，比遍历树的指针慢一步即可  
   而且从理论上，AVL树没有自底向上遍历的需求，如果代码中也不应为每个节点保存指向其父节点的指针  
   综上，我没有为AVL树节点保存其父节点的指针

画图：（画一些代表性的图，辅助理解）

1. 右旋
2. 插入平衡（LL型与LR型），附带节点高度与平衡因子计算、讲解
3. 删除过程

## 红黑树(red-black tree)(draft)

红黑树是一种自平衡二叉查找树，具有以下性质：

1. 每个节点都有且只有一个颜色：红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色
    1. 红黑树的叶子节点，是在传统意义上的叶子节点再向下抽象一层。这一句话对于理解概念没啥用处，只是为了实现方便(?)
    2. 本文档不采用该针对红黑树的**叶子节点**定义，以下提到**叶子节点**时，默认表示没有子节点的节点
4. 不能出现两个相连的红色节点
5. 任选一个节点作为根节点，根节点到它的每个叶子节点的路径上，都包含相同数量的黑色节点
    1. 推论：不存在一个节点，它只有一个黑色的子节点，而另一个子节点为空的情况

说明：红黑树不同于AVL树，它的左右子树高度可能相差很大，例如左子树黑-红相间，而右子树全黑。理论存在，实际不知道

红黑树通过左旋、右旋和变色实现平衡，其中左旋、右旋操作与AVL树一致

约定：针对插入操作，局部范围内，将准备插入的节点称为**新节点(n)**，新节点的父节点称为**父节点(p)**，父节点的父节点称为**根节点(r)**

红黑树的插入操作：`insert(key, value)`

1. 空树：生成新的节点作为根节点，颜色设置为黑色
2. 目标key已存在：更新对应节点的value
3. 父节点为黑色：生成新的节点作为子节点，颜色设置为红色
4. 父节点为红色：（插入新节点，参考上一步）
    1. 为什么父节点是叶子节点：新的节点要挂载到父节点上，所以父节点原本最多只有一个子节点；  
       又因为父节点为红色，如果有子节点，只能是黑色；而黑色的子节点又会改变性质5的值  
       结论：父节点是叶子节点  
       推论：父节点可以没有兄弟节点，如果有，一定是红色
    2. 父节点没有兄弟节点（即，此时的二叉树退化为链表）：（参考AVL树的旋转描述，R*型不平衡情况请自行镜像）
        1. LL型：根节点右旋；新的根节点设置为黑色，原根节点设置为红色
        2. LR型：父节点左旋，变成LL型，余下步骤按照LL型处理
        3. 平衡之后的根节点是黑色，其性质5的值没有变化（都是1），所以不需要额外平衡
    3. 父节点有兄弟节点：
        1. 将父节点及其兄弟节点设置为黑色，将根节点(r)设置为红色
        2. 若根节点(r)不存在父节点（即局部根节点即是整棵树的根节点），则将根节点设置为黑色（性质2）
        3. 若根节点存在父节点，且其父节点为黑色：不做任何操作
        4. 若根节点存在父节点，且其父节点为红色：将根节点(r)定义为新的待插入节点(n)，并基于此重新定义p、r
            1. 说明：因为p是红色的，所以它必然有父节点，即r必然存在
            2. p的另一个子节点（另一个子节点：相对于n）为黑色：将r设置为红色、p设置为黑色，向另一个子节点的方向旋转r
            3. p的另一个子节点为红色：设置p为红色、其两个子节点均为黑色，一直向上，直到**p是根节点**或**r为黑色**或**4.3.4.2.情景**

红黑树的插入操作存在自底向上的访问，所以在实现上，每个节点应持有指向其父节点的指针

红黑树的删除操作：`delete(key)`

- 只要删除节点往下，有一个红色节点

1. 找一个最深的红色节点，递归提升删除节点到红色节点这一段，将红色节点设置为黑色
2. 从红色节点开始向下递归，提升当前节点的一个子节点，如果存在另一个子节点，则设置其为红色，直到叶子节点；删除叶子节点
    1. 因为选择的红色节点已经是最深的了，不存在子节点还有红色的情况，所以在提升值的过程中，可以不考虑颜色

因为最终结果是删除了一个红色节点，不影响红黑树性质5，不需要额外的平衡操作

- 如果删除节点往下，全是黑色节点

1. 将删除节点左子节点提升上来，右子节点直接设置为红色
2. 从删除节点向下遍历提升节点，提升左子节点，将右子节点设置为红色，直到提升节点为叶子节点；删除提升节点
3. 从删除节点向上遍历，将父节点的另一个子节点设置为红色，直到根节点或父节点的另一个子节点已经是红色
    1. 如果父节点(p)的另一个子节点已经是红色，则将根节点(r)向黑色节点方向旋转，然后将新的根节点（原红色节点）设置为黑色，  
       如果新的根节点的一颗子树，在旋转过程中发生了重新挂载（即挂载到原根节点上），则将挂载树的根节点设置为红色

不同于删除红色节点，本节将删除一个黑色节点，导致删除节点到它每一个叶子节点路径上的黑色节点数量-1，所以需要向上平衡

## B树(B-tree)(draft)

> 部分资料将B树翻译为B-树，这是根据英文直译的，实际上指的就是B树

B树是一种自平衡的树，可以在对数时间内完成查找、顺序访问、插入以及删除操作

概括来说，B树是多叉查找树，与自平衡二叉查找树相比，B树适用于读写相对大的数据块的存储系统——例如磁盘，  
可以通过减少定位记录时所经历的中间过程，加快存取速度；常用于实现数据库与文件系统

用阶定义的B树（一颗m阶的B树）：
1. 每个节点最多有`m`个子节点(`m >= 2`)
2. 除根节点与叶子节点外，每个节点至少有`m/2`（向上取整）个子节点
3. 根节点可以没有子节点，或者有至少两个子节点
4. 所有叶子节点高度相同
5. 除根节点与叶子节点外，每个节点包含`n`个值与`n+1`个指针
