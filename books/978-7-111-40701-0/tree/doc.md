# tree

> 本节的树节点包含key、value数据，一棵树中不应存在key相同的节点，当试图插入一个key已存在的节点时，仅更新对应节点的value

## 二叉搜索树(binary search tree)

一般来说，BST更适用于查询场景，插入和删除场景与堆结构更匹配

二叉搜索树的性质：任取一个非叶子节点，它的左子树均比它小、右子树均比它大

约定：如果一个BST全部叶子节点的高度差不大于1，我们说这个BST是**高度平衡**的，简称**平衡**的

向BST插入数据，可能破坏BST的平衡结构，极端情况下，BST将变成单链表、查询效率将退化为`O(n)`，所以对BST进行插入或删除操作时，应额外维护其平衡结构

最早被发明的平衡二叉搜索树为AVL树

## AVL树(Adelson-Velsky and Landis Tree)

AVL树是自平衡的二叉搜索树，AVL树通过左旋、右旋操作平衡树的高度

右旋：（左旋是右旋的镜像）

1. 根节点的左子节点成为新的根节点
2. 若新根节点存在右子节点，则将其重新挂载成原根节点的左子节点
3. 原根节点成为新根节点的右子节点

约定：

1. h：节点高度，空节点高度为`-1`（方便计算），非空节点高度为**其左右子节点高度较大者+1**
2. b：平衡因子(balance factor)，仅定义于非空节点，计算规则为**节点的左子节点高度-节点的右子节点高度**
3. 根节点(n)：最先触发平衡的节点；其子节点使用`n.l/n.r`表示

当**平衡因子的绝对值大于1**时，开始平衡

1. LL型：因为在根节点左子节点的左子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) > 0`
    2. 右旋n
2. LR型：因为在根节点左子节点的右子节点挂载新的元素，导致破坏了原本的平衡结构
    1. 此时`b(n) > 1`且`b(n.l) < 0`
    2. 左旋n.l，右旋n
    3. 理解：左旋n.l后，同LL型
3. RR型：`b(n) < -1`且`b(n.r) < 0`，是LL型的镜像结构
4. RL型：`b(n) < -1`且`b(n.r) > 0`，是LR型的镜像结构

理解：

1. 触发平衡行为时，为什么只有上述四种情况呢？  
   说明：以下描述不考虑二叉树**镜像**情况，即对于RR情况的讨论，包含在LL情况中  
   在L*型不平衡情况中，我们通过右旋恢复平衡结构，而右旋，对于根节点的左子节点：其左子树高度不变，右子树高度+1  
   这可能导致根节点的左子节点的平衡结构被破坏  
   所以我们在右旋之前，首先保证根节点的左子节点，也就是新的根节点在右旋之后还是平衡的  
   至于实现方式，则是在新的根节点平衡因子为负时（右子树比左子树高），将其左旋一次
2. 为什么我没有为AVL树节点保存指向其父节点的指针？  
   从代码中可以看到，对AVL树节点的操作，大多用到了父节点，那么AVL树节点是否应持有其父节点的指针呢？否  
   首先，想要父节点，在编程上存在简单的解决方案：多维护一个父节点指针，比遍历树的指针慢一步即可  
   而且从理论上，AVL树没有自底向上遍历的需求，所以代码中也不应为每个节点保存指向其父节点的指针

## 红黑树(red-black tree)(draft)

红黑树是一种自平衡二叉查找树，具有以下性质：

1. 每个节点都有且只有一个颜色：红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色
    1. 红黑树的叶子节点，是在传统意义上的叶子节点再向下抽象一层。这一句话对于理解概念没啥用处，只是为了实现方便(?)
    2. 本文档不采用该针对红黑树的**叶子节点**定义，以下提到**叶子节点**时，默认表示没有子节点的节点
4. 不能出现两个相连的红色节点
5. 任选一个节点作为根节点，根节点到它的每个叶子节点的路径上，都包含相同数量的黑色节点
    1. 推论：不存在一个节点，它只有一个黑色的子节点，而另一个子节点为空的情况

说明：不同于AVL树，红黑树左右子树高度可能相差很大，例如左子树黑-红相间，而右子树全黑。但这个差不会超过一倍

红黑树通过左旋、右旋和变色实现平衡，其中左旋、右旋操作与AVL树一致

红黑树的本质是对概念模型：**2-3-4树**（阶数为4的B树）的一种实现(?)

```text
背景知识：
1. 2-3树的2节点：包含1个key、2个指针，指针分别指向`node.v < key`/`key < node.v`的子节点，使用一个黑色节点表示
2. 2-3树的3节点：包含2个key、3个指针，指针分别指向`node.v < key1`/`key1 < node.v < key2`/`key2 < node.v`的子节点，使用一个黑色节点带一个红色子节点表示
```

算法4给出的红黑树，是基于2-3树的实现，同时限定了所有红色节点都必须是左子节点（左倾）

从2-3树的角度解释红黑树的概念：

1. 黑色节点表示2节点，红色节点表示与黑色节点结合，表达3节点
2. 无论2-3树的根节点是2节点还是3节点，对应红黑树的根节点都是黑色
3. 略
4. 2节点和3节点均不会产生连续的红色节点
5. 红黑树中的红色节点与黑色节点关联，结合2-3树中只有黑色节点会贡献高度，反应到红黑树中，就是**黑色完美平衡**

### insert

2-3树的插入：（附带简单对应到红黑树的描述）

1. 向2节点插入-父节点为黑色节点且没有子节点：
    1. 直接插入-直接插入父节点，如果新节点是父节点的右子节点，则左旋黑色节点，然后变色，保证左倾性质
2. 向3节点插入-目标结构为*黑-红/空*，有三种情况：
    1. 新节点应插入黑色节点，作为黑色节点的右子节点：将新节点及其兄弟节点设置为黑色、父节点设置为红色，**定义父节点为新的新节点，向上平衡，直到根节点或新的父节点为黑色**
        1. 向上平衡：因为此时的父节点为红色，所以按照2.2或2.3处理
    2. 新节点应插入红色节点，作为红色节点的左子节点：右旋黑色节点，将黑色节点设置为红色、红色节点设置为黑色，然后按照2.1处理
    3. 新节点应插入红色节点，作为红色节点的右子节点：左旋红色节点，然后按照2.2处理

左倾红黑树的插入：

1. 父节点为黑色节点：
    1. 父节点无子节点：将新节点插入父节点，如果新节点是父节点的右子节点，则将父节点设置为红色、新节点设置为黑色，左旋父节点（保证左倾性质）
    2. 父节点存在红色左子节点，新节点将插入父节点，成为其右子节点：
        1. 说明：因为要插入到父节点，所以父节点最多有一个子节点
        2. 说明：因为性质5，父节点如果存在子节点，则必然是红色
        3. 说明：因为*黑-红/红*结构表示2-3树中的4节点，结合2-3树分裂4节点的操作，应执行如下操作
        4. 操作：将新节点及其兄弟节点设置为黑色、父节点设置为红色，**定义父节点为新的新节点，向上平衡，直到根节点或新的父节点为黑色**
        5. 向上平衡：因为此时属于连续红色节点，按照2处理
2. 父节点为红色节点：
    1. 新节点将成为其左子节点：将父节点设置为黑色、父节点的父节点设置为红色，右旋父节点的父节点，然后按照1.2处理
        1. 说明：左倾性质可以保证此处只有右旋一种可能
    2. 新节点将成为其右子节点：将新节点设置为黑色、父节点设置为红色，左旋父节点，然后按照2.1处理

我们可以看到，红黑树的插入操作中，有自底向上遍历的需求，所以在实现上，应为每个树节点维护指向其父节点的指针

### delete

左倾红黑树的删除：todo

## B树(B-tree)(draft)

> 部分资料将B树翻译为B-树，这是根据英文直译的，实际上指的就是B树

B树是一种自平衡的树，可以在对数时间内完成查找、顺序访问、插入以及删除操作

概括来说，B树是多叉查找树，与自平衡二叉查找树相比，B树适用于读写相对大的数据块的存储系统——例如磁盘，  
可以通过减少定位记录时所经历的中间过程，加快存取速度；常用于实现数据库与文件系统

用阶定义的B树（一颗m阶的B树）：

1. 每个节点最多有`m`个子节点(`m >= 2`)
2. 除根节点与叶子节点外，每个节点至少有`m/2`（向上取整）个子节点
3. 根节点可以没有子节点，或者有至少两个子节点
4. 所有叶子节点高度相同
5. 除根节点与叶子节点外，每个节点包含`n`个值与`n+1`个指针

### 2-3树(draft)

插入：先将新元素尝试放入已存在的节点，如果目标节点是2节点，则插入后变成3节点，如果目标节点是3节点，插入后变成4节点，则需要对4节点分裂

删除：如果要删除的元素在3节点中，直接删除即可，如果要删除的元素在2节点中：

1. 方案一：删除该2节点，对树做平衡
2. 方案二：想办法将问题转换成删除3节点中的元素（从父节点或兄弟节点借元素，构成3节点或4节点，删除后恢复）

我们重点看方案二，如果删除节点是二节点的情况：

1. 父节点与兄弟节点均为3节点：兄弟节点向父节点提供一个元素，父节点向删除节点提供一个元素，删除节点变成3节点，直接删除目标元素
2. 父节点为3节点，兄弟节点为2节点：父节点与兄弟节点均向删除节点提供一个元素，删除节点变成4节点，直接删除目标元素
3. 父节点与兄弟节点均为2节点：将父节点、兄弟节点与删除节点合并，成一个4节点，直接删除目标元素
