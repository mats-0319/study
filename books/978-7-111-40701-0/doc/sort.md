# sort

表格来源：算法导论4 p83

| algorithm      | worst time | average(expected) time | in place |
|----------------|------------|------------------------|----------|
| insertion sort | n^2        | n^2                    |          |
| merge sort     | n*lgn      | n*lgn                  |          |
| heap sort      | n*lgn      | -                      |          |
| quick sort     | n^2        | n*lgn                  |          |
| counting sort  | k+n        | k+n                    |          |
| base sort      | d(n+k)     | d(n+k)                 |          |

排序算法分类：

1. **比较排序**与**非比较排序**
    1. 比较排序：通过比较大小排列元素，例如快速排序
    2. 非比较排序：不需要通过比较大小来排列元素，例如计数排序
2. 是否满足**空间原址性**(in place)
    1. 空间原址性：任何时候都只需要常数个额外的元素空间存储临时变量，即所谓**原地修改**# 堆(heap)

## 堆(heap)

> 以最小二叉堆为例(binary minimum heap)

堆的特性与说明：

1. 父节点大于子节点的堆，称为最大堆；小于则称为最小堆
2. 堆只保证根节点是堆内最小的、以及最大值在叶子节点上
3. 堆更适用于**插入**、**删除**场景，搜索场景考虑**二叉搜索树**
4. 堆可以使用数组实现：
    1. 取消使用下标为`0`的元素
    2. 如果将数组下标对应到树节点，下标为`i`的节点：  
       其父节点下标为`i/2`，左子树下标为`i*2`，右子树下标为`i*2+1`  
       其中`i`的范围为`[1, 'heap size']`  
       若`i`的左子树下标超出堆大小，则`i`为叶子节点

## 基数排序(radix sort)

基数排序是桶排序的一种，多用于**正整数**排序，对于混合了正负整数的原始数组，我有两个思路：

1. 假装不知道有负整数，排序之后再过一遍：（从后往前遍历）因为先遍历到的数总是绝对值最大的，所以根据数值正负，从两边向中间填值
2. 正整数排序使用十个桶，那再用十个来排负整数就好了

分类：

1. LSD(least significant digital)：从最低位（个位）开始排序
2. MSD(most significant digital)：从最高位（根据测试数据）开始排序

实现：

1. 将所有数字补充至相同长度，在每个数字前面补0
    1. 假设绝对值最大的数字，有4位，则将所有不足4位的数字，通过在前面补0的方式补足4位；  
       这其实是一个方便理解的说法，代码实际不会真的补位
2. 根据每一位排序
    1. LSD：一次排序之后，恢复数组，再排下一次
    2. MSD：一次排序之后，在每个桶内，再次执行基数排序
