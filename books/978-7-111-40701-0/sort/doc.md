# sort

表格来源：算法导论4 p83

| algorithm      | worst time | average(expected) time | in place |
|----------------|------------|------------------------|----------|
| insertion sort | n^2        | n^2                    |          |
| merge sort     | n*lgn      | n*lgn                  |          |
| heap sort      | n*lgn      | -                      |          |
| quick sort     | n^2        | n*lgn                  |          |
| counting sort  | k+n        | k+n                    |          |
| radix sort     | d(n+k)     | d(n+k)                 |          |

排序算法分类：

1. **比较排序**与**非比较排序**
    1. 比较排序：通过比较大小排列元素，例如快速排序
    2. 非比较排序：不需要通过比较大小来排列元素，例如计数排序
2. 是否满足**空间原址性**(in place)
    1. 空间原址性：任何时候都只需要常数个额外的元素空间存储临时变量，即所谓**原地修改**
3. 是否属于**稳定排序算法**(stable)
    1. 稳定：如果有两个相同的元素，排序前后，它们的顺序是否可能改变；举个例子：按照分数排序，然后目标结构包含分数、姓名字段，排序前后，两个相同分数的人，顺序是否会变化

## 堆排序(heap sort)

> 以最小二叉堆为例(binary minimum heap)

堆的特性与说明：

1. 父节点大于子节点的堆，称为最大堆；小于则称为最小堆
2. 堆只保证根节点是堆内最小的、以及最大值在叶子节点上
3. 堆更适用于**插入**、**删除**场景，搜索场景考虑**二叉搜索树**
4. 堆可以使用数组实现：
    1. 取消使用下标为`0`的元素
    2. 如果将数组下标对应到树节点，下标为`i`的节点：  
       其父节点下标为`i/2`，左子树下标为`i*2`，右子树下标为`i*2+1`  
       其中`i`的范围为`[1, 'heap size']`  
       若`i`的左子树下标超出堆大小，则`i`为叶子节点

堆排序的思路：

1. push时，在堆的末尾插入，然后将新的节点*上升*
    1. 上升：将新节点与其父节点交换，将父节点重新定义为新节点；直到根节点，或新节点的值大于等于其父节点的值
    2. 这样每次push后，任意取一个节点，以该节点为根节点，得到的都是一个最小堆
2. pop时，取出堆顶元素，然后将最后一个元素移动到堆顶，将新的堆顶元素*下降*
    1. 下降：将根节点与其较小子节点交换，将交换的叶子节点重新定义为根节点；直到叶子节点，或子节点的值均大于等于父节点的值
    2. 这样每次pop后，任意取一个节点，以该节点为根节点，得到的都是一个最小堆

## 基数排序(radix sort)

基数排序是桶排序的一种，多用于**正整数**排序，对于混合了正负整数的原始数组，我有两个思路：

1. 假装不知道有负整数，排序之后再过一遍：（从后往前遍历）因为先遍历到的数总是绝对值最大的，所以根据数值正负，从两边向中间填值
2. 正整数排序使用十个桶，那再用十个来排负整数就好了

分类：

1. LSD(least significant digital)：从最低位（个位）开始排序
2. MSD(most significant digital)：从最高位（根据测试数据）开始排序

实现：

1. 将所有数字补充至相同长度，在每个数字前面补0
    1. 假设绝对值最大的数字，有4位，则将所有不足4位的数字，通过在前面补0的方式补足4位；  
       这其实是一个方便理解的说法，代码实际不会真的补位
2. 根据每一位排序
    1. LSD：一次排序之后，恢复数组，再排下一次
    2. MSD：一次排序之后，在每个桶内，再次执行基数排序
